{% extends "base.html" %}

{% block title %}Listing Details{% endblock %}

{% block content %}
<div class="listing-detail-container">
    <div id="listingDetail" class="listing-detail">
        <div class="loading">Loading listing...</div>
    </div>
</div>

<!-- Chat Modal -->
<div id="chatModal" class="chat-modal">
    <div class="chat-container">
        <div class="chat-header">
            <div class="chat-header-info">
                <div class="chat-recipient-name" id="chatRecipientName"></div>
                <div class="chat-listing-title" id="chatListingTitle"></div>
            </div>
            <div class="chat-header-actions">
                <div class="chat-menu">
                    <button class="chat-menu-btn" id="chatMenuBtn">
                        <span>â‹®</span>
                    </button>
                    <div class="chat-menu-dropdown" id="chatMenuDropdown" style="display: none;">
                        <button id="chatBlockBtn">Block User</button>
                        <button id="chatReportBtn">Report User</button>
                    </div>
                </div>
                <button class="chat-close" id="chatClose">&times;</button>
            </div>
        </div>
        <div class="chat-messages" id="chatMessages">
            <div class="loading">Loading messages...</div>
        </div>
        <div class="chat-input-area">
            <textarea id="chatInput" placeholder="Type a message..." rows="2"></textarea>
            <button id="sendMessage" class="btn btn-primary">Send</button>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
let currentUser = null;

// Check if user is logged in
function checkAuth() {
    const userEmail = localStorage.getItem('userEmail');
    if (userEmail) {
        currentUser = { email: userEmail };
        updateAuthUI();
    }
}

function updateAuthUI() {
    if (currentUser) {
        const loginBtn = document.querySelector('.btn-login');
        if (loginBtn) {
            const nickname = localStorage.getItem('userNickname') || currentUser.email.split('@')[0];
            loginBtn.textContent = nickname;
        }
    }
}

 (async function() {
    const listingId = '{{ listing_id }}';
    const container = document.getElementById('listingDetail');
    
    // Check auth on page load
    checkAuth();

    try {
        const res = await fetch(`/api/marketplace/listings/${listingId}`);
        const data = await res.json();
        if (!data.success) {
            container.innerHTML = '<p>Listing not found.</p>';
            return;
        }
        const l = data.listing;

        // Build images array (supports legacy single image_url or image_urls array)
        const images = (l.image_urls && l.image_urls.length) ? l.image_urls : (l.image_url ? [l.image_url] : []);

        container.innerHTML = `
            <div class="listing-body">
                <div class="listing-image-area">
                    <div class="image-frame" id="imageFrame">
                        ${images.length ? `<img id="mainImage" src="${images[0]}" alt="${l.title}">` : '<div class="image-placeholder">No image</div>'}
                        <div class="gallery-nav left" id="prevBtn" role="button" aria-label="Previous image" tabindex="0">â€¹</div>
                        <div class="gallery-nav right" id="nextBtn" role="button" aria-label="Next image" tabindex="0">â€º</div>
                    </div>
                    <div class="thumbs" id="thumbsContainer" role="list">
                        ${images.map((img, idx) => `<img class="thumb ${idx===0? 'active' : ''}" role="button" tabindex="0" aria-label="View image ${idx+1}" aria-selected="${idx===0? 'true' : 'false'}" data-idx="${idx}" src="${img}" alt="thumb-${idx}">`).join('')}
                    </div>
                </div>
                <div class="listing-info">
                    <div class="listing-info-card">
                        <h1 class="detail-title">${l.title}</h1>
                        <div class="detail-price">$${parseFloat(l.price).toFixed(2)}</div>
                        <div class="detail-meta">
                            <span class="detail-condition"><strong>Condition:</strong> ${l.condition}</span>
                            <span class="detail-category"><strong>Category:</strong> ${l.category}</span>
                        </div>
                        <div class="detail-description"><h3>Description</h3><p>${l.description || ''}</p></div>
                        ${l.isbn ? `<p><strong>ISBN:</strong> ${l.isbn}</p>` : ''}
                        ${l.class_tags && l.class_tags.length ? `<p><strong>Class Tags:</strong> ${l.class_tags.join(', ')}</p>` : ''}
                        <div class="seller-block">
                            <h3>Seller</h3>
                            <p><strong>${l.seller_name || 'Anonymous'}</strong><br>Contact: <a href="mailto:${l.contact}">${l.contact}</a></p>
                        </div>
                        <div class="listing-actions">
                            ${currentUser && currentUser.email === l.contact ? 
                                `<button class="btn btn-danger" id="deleteBtn" data-listing-id="${l.id}">Delete Listing</button>` : 
                                `<button class="btn btn-primary" id="contactBtn">Chat with Seller</button>`
                            }
                        </div>
                    </div>
                </div>
            </div>
        `;

        // Gallery behavior (fade, keyboard, swipe, accessibility)
        const thumbsContainer = document.getElementById('thumbsContainer');
        const mainImage = document.getElementById('mainImage');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const imageFrame = document.getElementById('imageFrame');
        let currentIdx = 0;

        function setActiveThumb(idx) {
            const thumbs = thumbsContainer ? Array.from(thumbsContainer.querySelectorAll('.thumb')) : [];
            thumbs.forEach((t, i) => {
                t.classList.toggle('active', i === idx);
                t.setAttribute('aria-selected', i === idx ? 'true' : 'false');
            });
        }

        function showImage(idx) {
            if (!images.length || !mainImage) return;
            const nextIdx = (idx + images.length) % images.length;
            currentIdx = nextIdx;
            // fade transition
            mainImage.classList.add('fade-out');
            const onLoad = () => {
                mainImage.classList.remove('fade-out');
                mainImage.removeEventListener('load', onLoad);
            };
            mainImage.addEventListener('load', onLoad);
            mainImage.src = images[currentIdx];

            setActiveThumb(currentIdx);
            const thumbs = thumbsContainer ? thumbsContainer.querySelectorAll('.thumb') : [];
            if (thumbs[currentIdx]) thumbs[currentIdx].scrollIntoView({ behavior: 'smooth', inline: 'center' });
        }

        if (thumbsContainer) {
            thumbsContainer.addEventListener('click', (ev) => {
                const t = ev.target.closest('.thumb');
                if (!t) return;
                const idx = parseInt(t.getAttribute('data-idx'));
                showImage(idx);
            });
            thumbsContainer.addEventListener('keydown', (ev) => {
                const t = ev.target.closest('.thumb');
                if (!t) return;
                if (ev.key === 'Enter' || ev.key === ' ') {
                    ev.preventDefault();
                    const idx = parseInt(t.getAttribute('data-idx'));
                    showImage(idx);
                }
            });
        }

        // initialize active thumb state
        setActiveThumb(0);

        if (prevBtn) {
            prevBtn.addEventListener('click', (e) => { e.stopPropagation(); showImage(currentIdx - 1); });
            prevBtn.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); showImage(currentIdx - 1); } });
        }
        if (nextBtn) {
            nextBtn.addEventListener('click', (e) => { e.stopPropagation(); showImage(currentIdx + 1); });
            nextBtn.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); showImage(currentIdx + 1); } });
        }

        // keyboard navigation
        document.addEventListener('keydown', (ev) => {
            if (ev.key === 'ArrowLeft') showImage(currentIdx - 1);
            if (ev.key === 'ArrowRight') showImage(currentIdx + 1);
        });

        // touch / swipe support
        if (imageFrame) {
            let touchStartX = 0;
            let touchEndX = 0;
            imageFrame.addEventListener('touchstart', (ev) => { touchStartX = ev.touches[0].clientX; }, { passive: true });
            imageFrame.addEventListener('touchmove', (ev) => { touchEndX = ev.touches[0].clientX; }, { passive: true });
            imageFrame.addEventListener('touchend', (ev) => {
                const dx = touchEndX - touchStartX;
                const threshold = 50;
                if (dx > threshold) { showImage(currentIdx - 1); }
                else if (dx < -threshold) { showImage(currentIdx + 1); }
            });
        }

        // Contact button behavior - open chat modal
        const contactBtn = document.getElementById('contactBtn');
        if (contactBtn) contactBtn.addEventListener('click', () => {
            if (!currentUser) {
                alert('Please log in to contact the seller');
                return;
            }
            // Check if user is trying to message themselves
            if (currentUser.email === l.contact) {
                alert('You cannot message yourself on your own listing!');
                return;
            }
            openChatModal(l);
        });
        
        // Delete button behavior - only visible to listing owner
        const deleteBtn = document.getElementById('deleteBtn');
        if (deleteBtn) {
            deleteBtn.addEventListener('click', async () => {
                if (!confirm('Are you sure you want to delete this listing? This cannot be undone.')) {
                    return;
                }
                
                try {
                    const res = await fetch(`/api/marketplace/listings/${l.id}`, {
                        method: 'DELETE'
                    });
                    
                    if (res.ok) {
                        alert('Listing deleted successfully');
                        window.location.href = '/marketplace';
                    } else {
                        const error = await res.json();
                        alert('Error deleting listing: ' + (error.error || 'Unknown error'));
                    }
                } catch (err) {
                    console.error('Error deleting listing:', err);
                    alert('Error deleting listing');
                }
            });
        }

    } catch (err) {
        console.error(err);
        container.innerHTML = '<p>Error loading listing.</p>';
    }
})();

// Chat functionality
let currentConversation = null;
let currentListing = null;
let messageRefreshInterval = null;

function openChatModal(listing) {
    currentListing = listing;
    const modal = document.getElementById('chatModal');
    const recipientName = document.getElementById('chatRecipientName');
    const listingTitle = document.getElementById('chatListingTitle');
    
    recipientName.textContent = listing.seller_name || 'Seller';
    listingTitle.textContent = listing.title;
    
    modal.style.display = 'flex';
    
    // Load or create conversation
    loadConversation(listing.contact, listing.id);
    
    // Start auto-refresh
    if (messageRefreshInterval) clearInterval(messageRefreshInterval);
    messageRefreshInterval = setInterval(() => {
        if (currentConversation) {
            loadMessages(currentConversation.id);
        }
    }, 3000);
}

function closeChatModal() {
    const modal = document.getElementById('chatModal');
    modal.style.display = 'none';
    currentConversation = null;
    currentListing = null;
    if (messageRefreshInterval) {
        clearInterval(messageRefreshInterval);
        messageRefreshInterval = null;
    }
}

async function loadConversation(recipientEmail, listingId) {
    try {
        // Get all conversations
        const res = await fetch('/api/messages/conversations', {
            headers: { 'X-User-Email': currentUser.email }
        });
        const conversations = await res.json();
        
        // Find existing conversation for this listing with this user
        const existing = conversations.find(c => 
            c.listing && c.listing.id === listingId && 
            c.other_user.email === recipientEmail
        );
        
        if (existing) {
            currentConversation = existing;
            loadMessages(existing.id);
        } else {
            // No conversation yet, create on first message
            currentConversation = {
                recipient_email: recipientEmail,
                listing_id: listingId
            };
            document.getElementById('chatMessages').innerHTML = '<div class="no-messages">Start the conversation!</div>';
        }
    } catch (err) {
        console.error('Error loading conversation:', err);
        document.getElementById('chatMessages').innerHTML = '<div class="error">Error loading conversation</div>';
    }
}

async function loadMessages(conversationId) {
    try {
        const res = await fetch(`/api/messages/conversation/${conversationId}`, {
            headers: { 'X-User-Email': currentUser.email }
        });
        
        if (!res.ok) {
            throw new Error('Failed to load messages');
        }
        
        const messages = await res.json();
        displayMessages(messages);
    } catch (err) {
        console.error('Error loading messages:', err);
    }
}

function displayMessages(messages) {
    const container = document.getElementById('chatMessages');
    
    if (!messages || messages.length === 0) {
        container.innerHTML = '<div class="no-messages">No messages yet. Start the conversation!</div>';
        return;
    }
    
    container.innerHTML = messages.map(msg => {
        const isSent = msg.sender_email === currentUser.email;
        const time = new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        
        // Group reactions by type
        const reactionCounts = {};
        (msg.reactions || []).forEach(r => {
            reactionCounts[r.type] = (reactionCounts[r.type] || 0) + 1;
        });
        
        const reactionsHtml = Object.keys(reactionCounts).length > 0 
            ? `<div class="message-reactions">${Object.entries(reactionCounts).map(([type, count]) => 
                `<span class="reaction">${type} ${count}</span>`).join('')}</div>`
            : '';
        
        return `
            <div class="message ${isSent ? 'sent' : 'received'}">
                <div class="message-bubble">
                    ${msg.reply_to ? `<div class="message-reply-preview">Replying to a message</div>` : ''}
                    <div class="message-content">${escapeHtml(msg.content)}</div>
                    <div class="message-meta">
                        <span class="message-time">${time}</span>
                        <button class="message-options" data-id="${msg.id}">â‹®</button>
                    </div>
                    ${reactionsHtml}
                </div>
            </div>
        `;
    }).join('');
    
    // Scroll to bottom
    container.scrollTop = container.scrollHeight;
    
    // Add event listeners for message options
    container.querySelectorAll('.message-options').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            showMessageOptions(btn.dataset.id, btn);
        });
    });
}

function showMessageOptions(messageId, buttonEl) {
    // Remove existing menu
    const existing = document.querySelector('.message-options-menu');
    if (existing) existing.remove();
    
    // Create menu
    const menu = document.createElement('div');
    menu.className = 'message-options-menu';
    menu.innerHTML = `
        <button class="menu-item" data-action="react">React</button>
        <button class="menu-item" data-action="reply">Reply</button>
    `;
    
    // Position menu
    const rect = buttonEl.getBoundingClientRect();
    menu.style.position = 'absolute';
    menu.style.top = rect.bottom + 'px';
    menu.style.left = rect.left + 'px';
    document.body.appendChild(menu);
    
    // Handle clicks
    menu.addEventListener('click', async (e) => {
        const action = e.target.dataset.action;
        menu.remove();
        
        if (action === 'react') {
            showReactionPicker(messageId);
        } else if (action === 'reply') {
            setReplyTo(messageId);
        }
    });
    
    // Close on click outside
    setTimeout(() => {
        document.addEventListener('click', function closeMenu() {
            menu.remove();
            document.removeEventListener('click', closeMenu);
        });
    }, 100);
}

function showReactionPicker(messageId) {
    const reactions = ['ðŸ‘', 'â¤ï¸', 'ðŸ˜‚', 'ðŸ˜®', 'ðŸ˜¢', 'ðŸ™'];
    const menu = document.createElement('div');
    menu.className = 'reaction-picker';
    menu.innerHTML = reactions.map(r => `<button class="reaction-btn">${r}</button>`).join('');
    
    document.body.appendChild(menu);
    
    menu.addEventListener('click', async (e) => {
        if (e.target.classList.contains('reaction-btn')) {
            await reactToMessage(messageId, e.target.textContent);
            menu.remove();
        }
    });
    
    setTimeout(() => {
        document.addEventListener('click', function closePicker() {
            menu.remove();
            document.removeEventListener('click', closePicker);
        });
    }, 100);
}

async function reactToMessage(messageId, reaction) {
    try {
        const res = await fetch(`/api/messages/${messageId}/react`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-User-Email': currentUser.email
            },
            body: JSON.stringify({ reaction })
        });
        
        if (res.ok && currentConversation) {
            loadMessages(currentConversation.id);
        }
    } catch (err) {
        console.error('Error reacting to message:', err);
    }
}

let replyToMessageId = null;

function setReplyTo(messageId) {
    replyToMessageId = messageId;
    const input = document.getElementById('chatInput');
    input.placeholder = 'Replying to a message... (Click to cancel)';
    input.focus();
}

async function reportMessage(messageId) {
    const reason = prompt('Please describe why you are reporting this message:');
    if (!reason) return;
    
    try {
        const res = await fetch(`/api/messages/${messageId}/report`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-User-Email': currentUser.email
            },
            body: JSON.stringify({ reason })
        });
        
        if (res.ok) {
            alert('Message reported. Thank you for keeping our community safe.');
        }
    } catch (err) {
        console.error('Error reporting message:', err);
        alert('Error reporting message. Please try again.');
    }
}

async function blockUser() {
    if (!currentListing) return;
    
    const confirmed = confirm(`Block ${currentListing.seller_name || 'this user'}? They will not be able to send you messages.`);
    if (!confirmed) return;
    
    try {
        const res = await fetch('/api/users/block', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-User-Email': currentUser.email
            },
            body: JSON.stringify({ blocked_email: currentListing.contact })
        });
        
        const result = await res.json();
        
        if (result.success || !result.error) {
            alert('User blocked successfully.');
            closeChatModal();
        } else {
            alert(`Error: ${result.error || 'Failed to block user'}`);
        }
    } catch (err) {
        console.error('Error blocking user:', err);
        alert('Error blocking user. Please try again.');
    }
}

async function sendMessage() {
    const input = document.getElementById('chatInput');
    const content = input.value.trim();
    
    if (!content) return;
    
    try {
        const payload = {
            sender_email: currentUser.email,
            recipient_email: currentListing.contact,
            listing_id: currentListing.id,
            content: content
        };
        
        if (replyToMessageId) {
            payload.reply_to = replyToMessageId;
        }
        
        const res = await fetch('/api/messages', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-User-Email': currentUser.email
            },
            body: JSON.stringify(payload)
        });
        
        const result = await res.json();
        
        if (result.error) {
            alert(`Error: ${result.error}`);
            return;
        }
        
        // Clear input
        input.value = '';
        replyToMessageId = null;
        input.placeholder = 'Type a message...';
        
        // If this was the first message, set the conversation
        if (!currentConversation.id) {
            // Reload conversations to get the new conversation ID
            const convRes = await fetch('/api/messages/conversations', {
                headers: { 'X-User-Email': currentUser.email }
            });
            const conversations = await convRes.json();
            const newConv = conversations.find(c => 
                c.listing && c.listing.id === currentListing.id && 
                c.other_user.email === currentListing.contact
            );
            if (newConv) {
                currentConversation = newConv;
            }
        } else {
            // Reload messages for existing conversation
            loadMessages(currentConversation.id);
        }
    } catch (err) {
        console.error('Error sending message:', err);
        alert('Error sending message. Please try again.');
    }
}

function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Event listeners
document.getElementById('chatClose').addEventListener('click', closeChatModal);
document.getElementById('sendMessage').addEventListener('click', sendMessage);
document.getElementById('chatInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
    }
});

// Chat menu handlers
document.getElementById('chatMenuBtn').addEventListener('click', (e) => {
    e.stopPropagation();
    const dropdown = document.getElementById('chatMenuDropdown');
    dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
});

document.getElementById('chatBlockBtn').addEventListener('click', async () => {
    if (!currentConversation) return;
    
    const recipientName = document.getElementById('chatRecipientName').textContent;
    if (!confirm(`Are you sure you want to block ${recipientName}? They will not be able to message you.`)) {
        return;
    }
    
    try {
        const res = await fetch('/api/users/block', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-User-Email': currentUser.email
            },
            body: JSON.stringify({ blocked_email: currentConversation.recipient_email })
        });
        
        if (res.ok) {
            alert(`${recipientName} has been blocked`);
            document.getElementById('chatMenuDropdown').style.display = 'none';
            closeChatModal();
        } else {
            const error = await res.json();
            alert('Error blocking user: ' + (error.error || 'Unknown error'));
        }
    } catch (err) {
        console.error('Error blocking user:', err);
        alert('Error blocking user');
    }
});

document.getElementById('chatReportBtn').addEventListener('click', async () => {
    if (!currentConversation) return;
    
    const recipientName = document.getElementById('chatRecipientName').textContent;
    const reason = prompt(`Why are you reporting ${recipientName}?\n\nPlease provide a reason:`);
    if (!reason || reason.trim() === '') {
        return;
    }
    
    try {
        const res = await fetch('/api/users/report', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-User-Email': currentUser.email
            },
            body: JSON.stringify({
                reported_email: currentConversation.recipient_email,
                reason: reason.trim(),
                context: 'chat'
            })
        });
        
        if (res.ok) {
            alert(`${recipientName} has been reported. Thank you for keeping the community safe.`);
            document.getElementById('chatMenuDropdown').style.display = 'none';
        } else {
            const error = await res.json();
            alert('Error reporting user: ' + (error.error || 'Unknown error'));
        }
    } catch (err) {
        console.error('Error reporting user:', err);
        alert('Error reporting user');
    }
});

// Close chat menu when clicking outside
document.addEventListener('click', (e) => {
    if (!e.target.closest('.chat-menu')) {
        document.getElementById('chatMenuDropdown').style.display = 'none';
    }
});

// Close modal on outside click
document.getElementById('chatModal').addEventListener('click', (e) => {
    if (e.target.id === 'chatModal') {
        closeChatModal();
    }
});

</script>
{% endblock %}
